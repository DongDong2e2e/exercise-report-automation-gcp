// =================================================================
// ================= 📊 대시보드 데이터 제공 함수 📊 =================
// =================================================================

/**
 * [수정됨] 대시보드 초기 로딩에 필요한 모든 데이터를 가공하여 반환하는 함수
 * 사용자의 주요 운동 목록을 Push, Pull, Legs 세 그룹으로 나누어 데이터를 추출합니다.
 */
function getDashboardData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const logSheet = ss.getSheetByName(getProjectConfig().STRUCTURED_LOG_SHEET);
  const inbodySheet = ss.getSheetByName(getProjectConfig().INBODY_SHEET);
  
  const threeMonthsAgo = new Date();
  threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
  const formatDate = (date) => Utilities.formatDate(date, Session.getScriptTimeZone(), 'yyyy-MM-dd');
  const threeMonthsAgoStr = formatDate(threeMonthsAgo);

  const logData = logSheet.getRange("A2:H" + logSheet.getLastRow()).getValues()
    .filter(row => row[0] && formatDate(new Date(row[0])) >= threeMonthsAgoStr);
  
  const inbodyData = inbodySheet.getRange("A2:F" + inbodySheet.getLastRow()).getValues()
    .filter(row => row[0] && formatDate(new Date(row[0])) >= threeMonthsAgoStr);

  // 운동 그룹별 데이터 추출을 위한 헬퍼 함수
  const extractWorkoutData = (exerciseList) => {
    const workoutData = {};
    exerciseList.forEach(exerciseName => {
      const exerciseLogs = logData.filter(row => row[1] && row[1].includes(exerciseName));
      if (exerciseLogs.length === 0) return;

      const dailyMax = {};
      exerciseLogs.forEach(row => {
        const dateStr = formatDate(new Date(row[0]));
        const weight = row[4];
        if (!dailyMax[dateStr] || weight > dailyMax[dateStr]) {
          dailyMax[dateStr] = weight;
        }
      });

      const sortedDates = Object.keys(dailyMax).sort();
      workoutData[exerciseName] = {
        labels: sortedDates,
        data: sortedDates.map(date => dailyMax[date])
      };
    });
    return workoutData;
  };

  // 1. Push 운동 데이터 추출
  const pushExercises = ['벤치프레스', '덤벨 숄더 프레스', '인클라인 체스트 프레스'];
  const pushData = extractWorkoutData(pushExercises);
  
  // 2. Pull & Hinge 운동 데이터 추출
  const pullExercises = ['루마니안 데드리프트', '티바 로우'];
  const pullData = extractWorkoutData(pullExercises);

  // 3. Leg 운동 데이터 추출
  const legExercises = ['레그 프레스', '브이 스쿼트', '리버스 브이 스쿼트', '힙 쓰러스트'];
  const legData = extractWorkoutData(legExercises);

  // 4. 인바디 데이터 추출
  const inbodyChartData = {
    labels: inbodyData.map(row => formatDate(new Date(row[0]))),
    weight: inbodyData.map(row => row[2]),
    muscle: inbodyData.map(row => row[3]),
    fatPercent: inbodyData.map(row => row[5] * 100)
  };

  return {
    pushData,
    pullData,
    legData,
    inbodyData: inbodyChartData
  };
}```
*(참고: `Code.gs`의 다른 부분은 수정할 필요 없습니다.)*

#### ✅ Step 2: `index.html` 수정

HTML 구조와 차트 생성 스크립트를 새로운 3+1 구조에 맞게 전면 수정합니다.

```html
<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif; margin: 0; padding: 20px; background-color: #f4f4f9; }
    .dashboard-container, .chat-container { max-width: 1000px; margin: auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
    
    .dashboard-container { padding: 20px; margin-bottom: 20px; }
    h2 { text-align: center; color: #333; }
    .chart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
    .chart-box { border: 1px solid #eee; padding: 15px; border-radius: 8px; }
    .chart-box h3 { margin-top: 0; text-align: center; font-size: 16px; color: #555;}

    .chat-container { display: flex; flex-direction: column; height: 80vh; max-height: 700px; }
    #chat-log { flex-grow: 1; overflow-y: auto; padding: 20px; border-bottom: 1px solid #ddd; }
    .message { margin-bottom: 15px; display: flex; flex-direction: column; }
    .user-message { align-items: flex-end; }
    .ai-message { align-items: flex-start; }
    .message p { padding: 10px 15px; max-width: 90%; line-height: 1.5; border-radius: 15px; }
    .user-message p { background-color: #007bff; color: white; border-bottom-right-radius: 0; }
    .ai-message p { background-color: #e9e9eb; color: #333; border-bottom-left-radius: 0; }
    #input-area { display: flex; padding: 10px; }
    #user-input { flex-grow: 1; border: 1px solid #ccc; border-radius: 20px; padding: 10px 15px; font-size: 16px; }
    #send-button { background-color: #007bff; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; margin-left: 10px; font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
  </style>
</head>
<body>

  <div class="dashboard-container">
    <h2>📊 나의 맞춤형 피트니스 대시보드</h2>
    <div class="chart-grid">
      <div class="chart-box">
        <h3>Push Strength (최고 중량)</h3>
        <canvas id="pushChart"></canvas>
      </div>
      <div class="chart-box">
        <h3>Pull & Hinge Strength (최고 중량)</h3>
        <canvas id="pullChart"></canvas>
      </div>
      <div class="chart-box">
        <h3>Leg Strength (최고 중량)</h3>
        <canvas id="legChart"></canvas>
      </div>
      <div class="chart-box">
        <h3>인바디 변화 (3개월)</h3>
        <canvas id="inbodyChart"></canvas>
      </div>
    </div>
  </div>

  <div class="chat-container">
    <div id="chat-log"></div>
    <div id="input-area">
      <input type="text" id="user-input" placeholder="궁금한 점을 물어보세요...">
      <button id="send-button" title="메시지 보내기">→</button>
    </div>
  </div>

  <script>
    const chatLog = document.getElementById('chat-log');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');

    const chartColors = { red: 'rgb(255, 99, 132)', orange: 'rgb(255, 159, 64)', yellow: 'rgb(255, 205, 86)', green: 'rgb(75, 192, 192)', blue: 'rgb(54, 162, 235)', purple: 'rgb(153, 102, 255)' };
    
    // [수정됨] 범용 차트 생성 헬퍼 함수
    function createMovementChart(canvasId, data) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      const datasets = Object.keys(data).map((exercise, index) => {
        const colorName = Object.keys(chartColors)[index % Object.keys(chartColors).length];
        return {
          label: exercise,
          data: data[exercise].data,
          borderColor: chartColors[colorName],
          fill: false,
          tension: 0.1,
          borderWidth: 2
        };
      });
      
      const allLabels = [...new Set(Object.values(data).flatMap(d => d.labels))].sort();
      
      datasets.forEach(dataset => {
        const newData = new Array(allLabels.length).fill(null);
        const originalLabels = Object.values(data).find(d => d.labels.length > 0).labels; // 임시방편
        Object.values(data).forEach(d => {
           d.labels.forEach((label, i) => {
               const index = allLabels.indexOf(label);
               if(index !==-1 && d.data[i] !== undefined) {
                  newData[index] = d.data[i];
               }
           });
        });
        
        let found = false;
        for(let key in data) {
           if(data[key].labels.length > 0) {
              originalLabels = data[key].labels;
              found = true;
              break;
           }
        }
        if(!found) return;

        data[datasets[0].label].labels.forEach((label, i) => {
            const index = allLabels.indexOf(label);
            if (index !== -1) {
                newData[index] = data[datasets[0].label].data[i];
            }
        });
        dataset.data = newData;
      });

      new Chart(ctx, {
        type: 'line',
        data: { labels: allLabels, datasets: datasets },
        options: { responsive: true, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top' } } }
      });
    }

    // 인바디 차트 생성 함수 (변경 없음)
    function createInbodyChart(data) {
      const ctx = document.getElementById('inbodyChart').getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.labels,
          datasets: [
            { label: '체중(kg)', data: data.weight, borderColor: chartColors.blue, yAxisID: 'y' },
            { label: '골격근량(kg)', data: data.muscle, borderColor: chartColors.red, yAxisID: 'y' },
            { label: '체지방률(%)', data: data.fatPercent, borderColor: chartColors.green, yAxisID: 'y1' }
          ]
        },
        options: { responsive: true, scales: { y: { position: 'left', title: { display: true, text: 'kg' } }, y1: { position: 'right', title: { display: true, text: '%' }, grid: { drawOnChartArea: false } } } }
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      appendMessage('ai', "안녕하세요! 나만의 맞춤형 대시보드를 준비했어요. 궁금한 점은 뭐든지 물어보세요!");

      google.script.run
        .withSuccessHandler(data => {
          if (Object.keys(data.pushData).length > 0) createMovementChart('pushChart', data.pushData);
          if (Object.keys(data.pullData).length > 0) createMovementChart('pullChart', data.pullData);
          if (Object.keys(data.legData).length > 0) createMovementChart('legChart', data.legData);
          if (data.inbodyData.labels.length > 0) createInbodyChart(data.inbodyData);
        })
        .withFailureHandler(err => console.error('대시보드 데이터 로드 실패:', err))
        .getDashboardData();
    });
    
    // (이하 챗봇 관련 JS는 이전 답변과 동일하게 유지)
    function appendMessage(sender, text) { /* 이전 답변과 동일 */ }
    function showLoader() { /* 이전 답변과 동일 */ }
    function removeLoader() { /* 이전 답변과 동일 */ }
    function handleSend() { /* 이전 답변과 동일 */ }
    sendButton.addEventListener('click', handleSend);
    userInput.addEventListener('keydown', event => { if (event.key === 'Enter') handleSend(); });

    // --- 복사해올 챗봇 JS 함수들 ---
    function appendMessage(sender, content) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'ai-message');
      if (sender === 'ai' && typeof content === 'object' && content.type === 'chart') {
        const p = document.createElement('p');
        p.textContent = `네, 요청하신 '${content.title}' 그래프를 준비했어요!`;
        messageDiv.appendChild(p);
        const chartContainer = document.createElement('div');
        chartContainer.style.height = '250px'; chartContainer.style.marginTop = '10px';
        const canvas = document.createElement('canvas');
        chartContainer.appendChild(canvas);
        messageDiv.appendChild(chartContainer);
        new Chart(canvas.getContext('2d'), { type: 'line', data: { labels: content.data.labels, datasets: [{ label: content.title, data: content.data.data, borderColor: chartColors.purple, tension: 0.1 }] }, options: { responsive: true, maintainAspectRatio: false } });
      } else {
        const p = document.createElement('p');
        p.textContent = content;
        messageDiv.appendChild(p);
      }
      chatLog.appendChild(messageDiv);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    function showLoader() { const loaderDiv = document.createElement('div'); loaderDiv.id = 'loader'; loaderDiv.classList.add('message', 'ai-message'); loaderDiv.innerHTML = '<p>분석 중입니다... 🤖</p>'; chatLog.appendChild(loaderDiv); chatLog.scrollTop = chatLog.scrollHeight; }
    function removeLoader() { const loader = document.getElementById('loader'); if (loader) loader.remove(); }
    function handleSend() { const message = userInput.value.trim(); if (!message) return; appendMessage('user', message); userInput.value = ''; userInput.disabled = true; sendButton.disabled = true; showLoader(); google.script.run.withSuccessHandler(response => { removeLoader(); appendMessage('ai', response); userInput.disabled = false; sendButton.disabled = false; userInput.focus(); }).withFailureHandler(error => { removeLoader(); appendMessage('ai', '죄송해요. 오류가 발생했어요: ' + error.message); userInput.disabled = false; sendButton.disabled = false; userInput.focus(); }).processUserMessage(message); }
  </script>
</body>
</html>
